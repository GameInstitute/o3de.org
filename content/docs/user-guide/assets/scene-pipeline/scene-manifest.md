---
linkTitle: Scene Manifest
title: Scene Manifest
description: Scene Manifest, 说明如何导出场景图
weight: 400
toc: true
---

```SceneManifest```包含如何处理```SceneGraph```内容的说明。虽然实现 IManifestObject 的任何东西都可以存储在清单中，但最常见的两种类型是组和规则（在用户界面中称为修改器）。

![Scene pipeline.](/images/user-guide/assets/scene-pipeline/scene-pipe-scene-settings.png)

Meshes、Actors PhysX 选项卡是通过场景清单组动态确定的。

## 场景清单组和规则

组代表一组操作的发起者，如转换和写入 O3DE 数据。虽然组与特定的文件格式没有特别的联系，可以产生多种产品，也可以不产生任何产品，但它们通常围绕着一个单一的类型。例如，网格组用于静态网格，主要生成渲染产品资产文件。组的目标是包含完成工作所需的最少配置选项。实际上，这意味着它们应始终生成有效的产品，不过这里的有效是指产品不会导致崩溃，而不一定是指它们完全代表了源数据。


为了更接近或与源数据完全相同，需要添加规则。规则用于微调分组所代表的指令。通常情况下，这些组群由物理或材料等共同功能组成。规则可以有多个选项，但一个空规则就足以添加/更改处理步骤。例如，默认情况下，Atom 场景生成器会为网格组容器生成 LOD，但添加一条空白的 LodRule 就可以跳过这一步。
一个组及其规则通常由一个或多个导出组件读取。例如，负责转换静态网格的导出组件会查找网格组，如果找到，就会创建一个包含网格组中所选网格的模型容器。另一个导出组件（如处理物理的组件）会对静态网格导出器发送的新碰撞网格通知做出反应。然后，它会查看所使用的网格组，并寻找坐标系规则（CoordinateSystemRule），如果找到，就会使用场景图（```SceneGraph```）中的信息更新系统。

加载和导出组件都使用这种方法来分解任务。单个类不需要了解所有可能的组合，而是将工作分散到更小的部分，这些部分通过名为 CallProcessor 的特殊 EBus 连接起来。这样还可以更方便地注入自定义代码，而无需修改原始源代码。

加载源场景后，总会有一个```SceneManifest```存在。首先会尝试从扩展名为 .assetinfo 的文件中读取```SceneManifest```。该名称会附加到源文件的文件路径上，例如 “example/file.fbx ”会导致场景管道在 “example/file.fbx.assetinfo ”中查找清单。如果找不到该文件，场景管道将在内存中创建一个新的清单，稍后可能会保存到磁盘，也可能不会。与其创建一个空白的清单或带有几个默认值的清单，不如由几段较小的代码（请参阅 “组件 - 行为”）来分析```SceneGraph```，并使用各种逻辑和知识来构建一个可能产生用户所需的结果的清单。如果系统成功加载了场景清单，那么这些代码就有机会查看清单和图的状态，以便修改任何不一致之处。
