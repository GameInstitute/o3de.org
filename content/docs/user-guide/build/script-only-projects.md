---
linktitle: 仅脚本的'Quick Start'项目
title: 仅脚本的'Quick Start'项目
description: 说明仅脚本的'Quick Start'项目如何在 O3DE 中运行
weight: 100
toc: true
---

O3DE 中的项目可以在一种模式下创建，该模式禁止所有 C++ 编译和链接，包括下载这些链接器可能使用的任何库。 在这种 “纯脚本 ”模式下，项目只能使用共享库中的预编译 gem 和组件，但仍可使用 Lua 和 Script Canvas 创建游戏逻辑，并使用 Python 创建编辑器工具。

纯脚本模式也被称为 "Quick Start" 模式，因为不需要使用 C++ 编译或链接任何东西，这意味着项目的 “构建时间 ”非常短（几秒钟），迭代速度也更快。

纯脚本模式的缺点是，游戏项目本身无法创建和使用任何 C++ 组件，除非这些组件是通过其他方式预先构建并由其他构建系统注入的，而且所有使用的现有库也必须是预先构建的，例如引擎安装布局中包含的库。

第三方Gem和插件只有在预编译的情况下才能使用。

尽管有这些限制，但它仍是一种快速进入编辑器并立即开始创建的方法，无需下载编译器，也无需下载任何额外的 c++ 开发库（如 Qt SDK）。

## 创建纯脚本项目
你可以使用 ScriptOnlyProject [模板](/docs/user-guide/build/templates.md)创建一个新的纯脚本项目，更多信息请参阅 [创建项目](/docs/welcome-guide/create)文档。

您也可以通过修改项目根目录下的 `project.json` 文件，将现有项目转换为纯脚本项目。 决定项目是否为纯脚本项目的标志是`project.json`根目录中的以下标记：
```json
"script_only": true,
```

默认值为 false，因此没有此标记的项目不是纯脚本项目。
如果将现有项目转换为脚本专用，可能需要移除其中已存在的 C++ 模块，或从构建系统中禁用这些模块，或遇到错误。

您可能还需要将现有纯脚本项目（或 `templates` 文件夹中的纯脚本项目模板）中的 `EngineFinder.cmake` 文件复制到项目的 cmake 子文件夹中。

## 将纯脚本项目转换为编译后项目

要切换回 “正常 ”项目，只需将上述标志设为 false，或从 `project.json` 中删除即可。
然后，你就可以开始在项目中添加 C++ 组件，或使用 [模板](/docs/user-guide/build/templates.md) 系统实例化新的 C++ 组件。 您可能需要修改 CMake 生成文件，以包含包含代码的新子目录，就像其他项目一样。

## 发送纯脚本项目
纯脚本项目的根目录包含一个脚本，用于将项目导出为独立项目。 有关项目导出功能的详细信息，请参阅[项目导出](content/docs/user-guide/packaging/project-export) 文档，因为它与普通项目使用相同的导出系统。

## 需要注意的权衡

### 没有单片构建
由于不涉及 C++ 编译器或链接器，也不下载第三方库，因此打包和发布纯脚本模式项目将以通用动态链接游戏启动器的形式发布，而不是最终发布的单体可执行文件。 这意味着最终的软件包会更大，并包含共享库（Windows 上为 DLL），而不是一个巨大的单体可执行文件。

制作这样的可执行文件需要编译器和链接器。 如果你想继续使用单体构建，但又想将其作为纯脚本项目，那么可以将其切换为常规项目，甚至可以在构建前修改软件包脚本，通过构建管道在调用导出脚本时自动修改 `project.json` 来临时这样做。

### 您使用的所有模块和 gem 必须已编译过
由于不涉及编译器或链接器，您激活的所有 gem 和需要使用的所有其他第三方内容都必须以 CMake 可以使用而无需编译的形式存在（例如，预编译的 dll 文件，而不是带头文件的静态库）。 当使用安装程序中的预置引擎（或自己制作）时，引擎中包含的所有 gem 都必须如此。 从其他网站下载的一些第三方Gem可能只包含源代码，或经过编译并链接到游戏中的源代码存根。 这些Gem在纯脚本模式下无法运行，除非这些Gem的开发者创建并发布了特殊的预编译版本，或许可以使用预构建的Gem [模板](/docs/user-guide/build/templates.md)。

## 工作原理（技术描述）
当 CMake 配置 O3DE 时，项目中的一个脚本 (`EngineFinder.cmake`)会将 CMake 全局属性 `O3DE_SCRIPT_ONLY` 设置为 `TRUE`。 这发生在 CMake 项目命令之前，也就是 CMake 自动选择编译器之前。 当该属性为`TRUE`时，O3DE 的 CMake 脚本通常会配置编译器、链接器和其他编译工具，但会设置一个 null 编译器，这是一个简单的程序，总是返回成功。

CMake 仍会像 “真实 ”项目一样被调用，但所有编译和链接操作基本上都是瞬时的，而且总是会成功（实际上不会生成任何二进制文件）。 不过，由于所有二进制文件都预置在安装程序中（纯脚本项目不包含自定义二进制文件），因此这足以构建并运行编辑器和游戏。

在 CMake 配置过程中，也会跳过第三方软件包的下载，取而代之的是，通常会获取的第三方库将仅从其共享库和其他文件中合成。 CMake 在配置和构建安装镜像时，会收集依赖树中的共享库列表和动态链接信息。 在此过程中，位于 `cmake/3rdParty/script-only-mode/PostProcessScriptOnlyMappings.cmake` 中的脚本会根据配置时发出的第三方库信息（如所需的额外文件或共享库）在构建时运行。 该脚本本质上是生成一个 CMake 文件，其中包含伪造的 “导入 ”第三方目标，以提供必要的共享库和其他文件，否则这些文件将来自第三方软件包，并将其指向作为安装程序一部分的对应文件。

最后，我们会向 CMake 声明项目的 “假 ”游戏启动器，它依赖于预制的通用游戏启动器可执行文件。 这个通用游戏启动器是作为安装映像构建的一部分构建的，它将读取 project.json 来确定项目名称和其他信息，而不是依赖二进制文件中的数据。

由于编译器和链接器都是假的，CMake 不会实际编译或链接这个 “假 ”目标，但仍会认为它已经成功，并将其依赖的东西（递归）复制到二进制文件文件夹，这就是通用游戏启动器及其所有依赖的东西最终出现在二进制文件文件夹的原因。

这意味着希望为其模块支持纯脚本模式的开发人员可以这样做，但需要在发货时提供预构建的共享库，这些库在 cmake 中以 `add_library(name SHARED IMPORTED GLOBAL)` 的形式公开，并在声明中使用正常的 cmake 约定列出其运行时依赖关系。
